package network

import (
	"context"
	"fmt"
	"os"
	"os/exec"
	"strconv"
	"syscall"

	"github.com/onkernel/hypeman/lib/logger"
)

// startDNS starts dnsmasq process
// TODO @sjmiller609 review: why not just use systemd to manage dnsmasq? conflict with on-system dnsmasq? what about other dns server options?
func (m *manager) startDNS(ctx context.Context) error {
	log := logger.FromContext(ctx)

	// Check if already running
	if m.isDNSRunning() {
		log.DebugContext(ctx, "dnsmasq already running")
		return nil
	}

	// 1. Ensure network directory exists
	if err := os.MkdirAll(m.paths.NetworkDir(), 0755); err != nil {
		return fmt.Errorf("create network dir: %w", err)
	}

	// 2. Generate dnsmasq.conf
	if err := m.generateDNSConfig(ctx); err != nil {
		return fmt.Errorf("generate DNS config: %w", err)
	}

	// 3. Generate initial dnsmasq.hosts
	if err := m.generateDNSHosts(ctx); err != nil {
		return fmt.Errorf("generate DNS hosts: %w", err)
	}

	// 4. Start dnsmasq
	confPath := m.paths.NetworkDnsmasqConf()
	cmd := exec.Command("dnsmasq", "-C", confPath)

	if err := cmd.Start(); err != nil {
		return fmt.Errorf("start dnsmasq: %w", err)
	}

	// 5. Store PID
	pidPath := m.paths.NetworkDnsmasqPid()
	if err := os.WriteFile(pidPath, []byte(fmt.Sprintf("%d", cmd.Process.Pid)), 0644); err != nil {
		// Best effort - kill process if PID write fails
		cmd.Process.Kill()
		return fmt.Errorf("write PID file: %w", err)
	}

	log.InfoContext(ctx, "started dnsmasq", "pid", cmd.Process.Pid)
	return nil
}

// stopDNS stops dnsmasq process
func (m *manager) stopDNS() error {
	pidPath := m.paths.NetworkDnsmasqPid()

	pidData, err := os.ReadFile(pidPath)
	if err != nil {
		// PID file doesn't exist or can't be read
		return nil
	}

	pid, err := strconv.Atoi(string(pidData))
	if err != nil {
		return fmt.Errorf("parse PID: %w", err)
	}

	// Send SIGTERM
	if err := syscall.Kill(pid, syscall.SIGTERM); err != nil {
		// Process might already be dead
		return nil
	}

	// Remove PID file
	os.Remove(pidPath)

	return nil
}

// isDNSRunning checks if dnsmasq is running
func (m *manager) isDNSRunning() bool {
	pidPath := m.paths.NetworkDnsmasqPid()

	pidData, err := os.ReadFile(pidPath)
	if err != nil {
		return false
	}

	pid, err := strconv.Atoi(string(pidData))
	if err != nil {
		return false
	}

	// Check if process exists
	process, err := os.FindProcess(pid)
	if err != nil {
		return false
	}

	// Send signal 0 to check if process is alive
	err = process.Signal(syscall.Signal(0))
	return err == nil
}

// reloadDNS regenerates hosts file and signals dnsmasq to reload
func (m *manager) reloadDNS(ctx context.Context) error {
	log := logger.FromContext(ctx)

	// 1. Generate DNS hosts file
	if err := m.generateDNSHosts(ctx); err != nil {
		return fmt.Errorf("generate DNS hosts: %w", err)
	}

	// 2. If DNS not running, start it
	if !m.isDNSRunning() {
		return m.startDNS(ctx)
	}

	// 3. Send HUP signal to reload
	pidPath := m.paths.NetworkDnsmasqPid()
	pidData, err := os.ReadFile(pidPath)
	if err != nil {
		// Can't read PID, try to restart
		log.WarnContext(ctx, "failed to read dnsmasq PID, restarting", "error", err)
		m.stopDNS()
		return m.startDNS(ctx)
	}

	pid, err := strconv.Atoi(string(pidData))
	if err != nil {
		return fmt.Errorf("parse PID: %w", err)
	}

	if err := syscall.Kill(pid, syscall.SIGHUP); err != nil {
		// Process might be dead, try to restart
		log.WarnContext(ctx, "failed to signal dnsmasq, restarting", "error", err)
		m.stopDNS()
		return m.startDNS(ctx)
	}

	log.DebugContext(ctx, "reloaded dnsmasq")
	return nil
}

// generateDNSConfig generates dnsmasq.conf
// Note: dnsmasq is used for simplicity. Alternatives like coredns would add complexity
// without significant benefit for a single-network setup.
func (m *manager) generateDNSConfig(ctx context.Context) error {
	// Get default network for listen address
	defaultNet, err := m.getDefaultNetwork(ctx)
	if err != nil {
		return err
	}

	// Build listen address for default network
	listenAddresses := fmt.Sprintf("listen-address=%s\n", defaultNet.Gateway)

	config := fmt.Sprintf(`# Generated by hypeman network manager
# Do not edit manually

# Don't run as daemon (we manage the process)
no-daemon

# Don't read /etc/hosts
no-hosts

# Don't read /etc/resolv.conf
no-resolv

# Use our hosts file
addn-hosts=%s

# PID file
pid-file=%s

# Listen on bridge gateway IPs
%s

# Upstream DNS servers
server=1.1.1.1
server=8.8.8.8

# Local domain
local=/hypeman/
domain=hypeman

# Cache size
cache-size=1000

# Log queries (optional, for debugging)
# log-queries
`, m.paths.NetworkDnsmasqHosts(), m.paths.NetworkDnsmasqPid(), listenAddresses)

	confPath := m.paths.NetworkDnsmasqConf()
	if err := os.WriteFile(confPath, []byte(config), 0644); err != nil {
		return fmt.Errorf("write DNS config: %w", err)
	}

	return nil
}

// generateDNSHosts generates dnsmasq.hosts file
func (m *manager) generateDNSHosts(ctx context.Context) error {
	// Get all allocations
	allocations, err := m.ListAllocations(ctx)
	if err != nil {
		return fmt.Errorf("list allocations: %w", err)
	}

	// Build hosts file
	hosts := "# Generated by hypeman network manager\n"
	hosts += "# Do not edit manually\n\n"

	for _, alloc := range allocations {
		// Add entries for:
		// - {name}.{network}.hypeman
		// - {id}.{network}.hypeman
		nameEntry := fmt.Sprintf("%s.%s.hypeman", alloc.InstanceName, alloc.Network)
		idEntry := fmt.Sprintf("%s.%s.hypeman", alloc.InstanceID, alloc.Network)

		hosts += fmt.Sprintf("%s  %s %s\n", alloc.IP, nameEntry, idEntry)
	}

	hostsPath := m.paths.NetworkDnsmasqHosts()
	if err := os.WriteFile(hostsPath, []byte(hosts), 0644); err != nil {
		return fmt.Errorf("write DNS hosts: %w", err)
	}

	return nil
}

